[[call]]
:description: This page describes how to create CALL subqueries with the Cypher Builder.
= `Call`

Cypher link:https://neo4j.com/docs/cypher-manual/current/subqueries/call-subquery/[`CALL` subqueries] can be created with `new Cypher.Call()` in Cypher Builder.
To do this, a valid query needs to be passed to `Call`, for example:

[source, javascript]
----
const dog = new Cypher.Node({ labels: ["Dog"] });
const person = new Cypher.Node({ labels: ["Person"] });

const dogName = new Cypher.NamedVariable("dogName")

const subquery = new Cypher.Match(
    new Cypher.Pattern(person).related(new Cypher.Relationship({ type: "HAS_DOG" })).to(dog)
).return([dog.property("name"), dogName]);

const classClause = new Cypher.Call(subquery).return(dogName);
----

[source, cypher]
----
CALL {
    MATCH (this0:Person)-[this1:HAS_DOG]->(this2:Dog)
    RETURN this2.name AS dogName
}
RETURN dogName
----


== `.importWith`

To add variables to a `CALL` subquery context, you need to add a `WITH` statement.
This can be achieved by using the `.importWith` method:

[source, javascript]
----
const dog = new Cypher.Node({ labels: ["Dog"] });
const person = new Cypher.Node({ labels: ["Person"] });

const dogName = new Cypher.NamedVariable("dogName");

const subquery = new Cypher.Match(
    new Cypher.Pattern(person).related(new Cypher.Relationship({ type: "HAS_DOG" })).to(dog)
).return([dog.property("name"), dogName]);

const match = new Cypher.Match(person);

const callSubquery = new Cypher.Call(subquery).importWith(person).return(dogName);

const clause = Cypher.concat(match, subquery);
----

[source, cypher]
----
MATCH (this0:Person)
CALL {
    WITH this0
    MATCH (this0:Person)-[this1:HAS_DOG]->(this2:Dog)
    RETURN this2.name AS dogName
}
RETURN dogName
----

Note how the previous example uses `.concat` to concatenate the first `MATCH` statement and the `CALL` clause.


== `.inTransactions`

A `CALL` subquery can be executed in separate transactions by using the `inTransaction` method:

[source, javascript]
----
const node = new Cypher.Node();

const match = new Cypher.Match(node);
const deleteSubquery = new Cypher.With(node).detachDelete(node);
const callSubquery=new Cypher.Call(deleteSubquery).inTransactions();


const query = Cypher.concat(match, callSubquery);
----

[source, cypher]
----
MATCH (this0)
CALL {
    WITH this0
    DETACH DELETE this0
} IN TRANSACTIONS
----

The method `inTransaction` accepts an object with the following options:

* `ofRows`: A number to define the batch of rows. Translates to `IN TRANSACTIONS OF 10 ROWS`
* `onError`: A behavior for error handling. This can be `continue`, `break` or `fail`. Translates to `ON ERROR CONTINUE`
