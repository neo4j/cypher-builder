[[call]]
:description: This page describes how to create CALL subqueries with the Cypher Builder.
= `Call`

`Cypher.Call` generates Cypher link:https://neo4j.com/docs/cypher-manual/current/subqueries/call-subquery/[`CALL` subqueries]. To do this, instantiate `Cypher.Call` with a valid subquery as parameter in the constructor.

[source, javascript]
----
new Cypher.Call(subquery);
----

In the following example, `Cypher.Call` receives a `Cypher.Match` clause.

[source, javascript]
----
const dog = new Cypher.Node({ labels: ["Dog"] });
const person = new Cypher.Node({ labels: ["Person"] });
const dogName = new Cypher.NamedVariable("dogName");

const pattern = new Cypher.Pattern(person).related(new Cypher.Relationship({ type: "HAS_DOG" })).to(dog)
const subquery = new Cypher.Match(pattern).return([dog.property("name"), dogName]);

const callClause = new Cypher.Call(subquery).return(dogName);
const { cypher, params } = callClause.build();
----

This example builds a `CALL` clause with the `MATCH` subquery inside.

[source, cypher]
----
CALL {
    MATCH (this0:Person)-[this1:HAS_DOG]->(this2:Dog)
    RETURN this2.name AS dogName
}
RETURN dogName
----

== Variable scope

xref:../variables-and-params/variables.adoc[Variables] can be added to the `CALL` scope by passing the to the second parameter of the constructor, as an array. These variables will be available within the scope of the subquery in the generated Cypher.

[source, javascript]
----
new Cypher.Call(subquery, [var1, var2]);
----

The following code will make two node variables available in the `CREATE` statement inside `CALL`.

[source, javascript]
----
const movieNode = new Cypher.Node();
const actorNode = new Cypher.Node();

const createSubquery = new Cypher.Create(new Cypher.Pattern(movieNode).related().to(actorNode));

const clause = new Cypher.Call(createSubquery, [
    movieNode,
    actorNode,
]);
----

The resulting Cypher adds the two variables `movieNode` (`this0`) and `actorNode` (`this1`) to the `CALL` scope:

[source, cypher]
----
CALL (this0, this1) {
    CREATE (this0)-[this2]->(this1)
}
----

To import all variables from the outer scope, set the second parameter to the string `"*"`:

[source, javascript]
----
const movieNode = new Cypher.Node();
const actorNode = new Cypher.Node();

const createSubquery = new Cypher.Create(new Cypher.Pattern(movieNode).related().to(actorNode));

const clause = new Cypher.Call(createSubquery, "*");
----

[source, cypher]
----
CALL (*) {
    CREATE (this0)-[this2]->(this1)
}
----

[role=label--deprecated]
== `.importWith`

[WARNING]
====
This method is deprecated in favor of <<_variable_scope>>.
====

[WARNING]
====
`ImportWith` cannot be used if scope variables are defined and will throw an error.
====


To add variables to a `CALL` subquery context, you need to add a `WITH` statement.
This can be achieved by using the `.importWith` method:

[source, javascript]
----
const dog = new Cypher.Node();
const person = new Cypher.Node();

const dogName = new Cypher.NamedVariable("dogName");

const subquery = new Cypher.Match(
    new Cypher.Pattern(person, {labels: ["Person"]}).related(new Cypher.Relationship({ type: "HAS_DOG" })).to(dog, {labels: ["Dog"]})
).return([dog.property("name"), dogName]);

const clause = new Cypher.Match(new Cypher.Pattern(person, {labels: ["Person"]})).call(subquery).importWith(person).return(dogName);
----

[source, cypher]
----
MATCH (this0:Person)
CALL {
    WITH this0
    MATCH (this0:Person)-[this1:HAS_DOG]->(this2:Dog)
    RETURN this2.name AS dogName
}
RETURN dogName
----

Note how the previous example uses `.concat` to concatenate the first `MATCH` statement and the `CALL` clause.

== `.inTransactions`

The method `.inTransactions` appends the modifier `IN TRANSACTIONS` at the end of the `CALL` subquery, this way subqueries will link:https://neo4j.com/docs/cypher-manual/current/subqueries/subqueries-in-transactions/[execute in separate transactions]:

[source, javascript]
----
new Call(subquery).inTransactions();
----

[source, cypher]
----
CALL {
    // Subquery
} IN TRANSACTIONS
----

The method `inTransactions` accepts multiple settings to change the behaviour of the transactions, such as, error handling, rows per transaction, or concurrency. You can pass one or more settings, as an object, to `.inTransaction`.

[source, javascript]
----
new Call(subquery).inTransactions({
    ofRows: 10
});
----

`inTransactions` supports the following settings:

[cols="1,1,1",options="header"]
|===
| Setting | Description | Cypher
| `ofRows` | Define the number of rows per transaction | link:https://neo4j.com/docs/cypher-manual/current/subqueries/subqueries-in-transactions/#batching[`IN TRANSACTIONS OF [n\] ROWS`]
| `onError` | Error handling behaviour, can be  `continue`, `break` or `fail` | link:https://neo4j.com/docs/cypher-manual/current/subqueries/subqueries-in-transactions/#error-behavior[`ON ERROR [CONTINUE \| BREAK \| FAIL\]`]
| `concurrentTransactions` | The maximum number of transactions to execute concurrently | link:https://neo4j.com/docs/cypher-manual/current/subqueries/subqueries-in-transactions/#concurrent-transactions[`IN [n\] CONCURRENT TRANSACTIONS`]
| `retry` | If set to `true`, retries failing transactions. Can be a number to define the maximum duration, in seconds. | link:https://neo4j.com/docs/cypher-manual/current/subqueries/subqueries-in-transactions/#on-error-retry[`ON ERROR RETRY [FOR x SECONDS\]`] 
|===


**Example 1: Concurrent transaction of rows**

[source, javascript]
----
const clause = new Cypher.Call(subquery).inTransactions({
    ofRows: 10,
    concurrentTransactions: 5
});
----


[source, cypher]
----
CALL {
    // subquery
} IN 5 CONCURRENT TRANSACTIONS OF 10 ROWS
----

**Example 2: Retry with maximum duration**

[source, javascript]
----
const clause = new Cypher.Call(subquery).inTransactions({
    retry: 10
});
----


[source, cypher]
----
CALL {
    // subquery
} TRANSACTIONS ON ERROR RETRY FOR 10 SECONDS
----

**Example 3: Retry error fallback**

[source, javascript]
----
const clause = new Cypher.Call(subquery).inTransactions({
    retry: true,
    onError: "continue"
});
----


[source, cypher]
----
CALL {
    // subquery
} TRANSACTIONS ON ERROR RETRY THEN CONTINUE
----


== Optional Call

The method `.optional()` transforms a `CALL` subquery into link:https://neo4j.com/docs/cypher-manual/current/subqueries/call-subquery/#optional-call[`OPTIONAL CALL`] subquery.

[source, javascript]
----
new Cypher.Call(subquery).optional();
----

Alternatively, the clause `OptionalCall` creates an `OPTIONAL CALL` directly:

[source, javascript]
----
new Cypher.OptionalCall(deleteSubquery);
----

Both generate the Cypher:

[source, cypher]
----
OPTIONAL CALL {
    // Subquery
}
----
