[[migration]]
:description: This page describes how to migrate to version 3.x from version 2
= Migration to Cypher Builder 3

Cypher Builder 3 targets Cypher 5 and 25, dropping support for Cypher 4. If you need to support Cypher 4, stay with Cypher Builder 2.x, otherwise, migrate to version 3.

== Compatibility changes

=== Minimum node engine changed to 20.0.0

Node.js 16 is no longer supported. Update to version 20.0.0 or above.

=== Cypher 4 no longer supported

Cypher 4, and Neo4j 4 databases are no longer supported. Cypher Builder targets Cypher 5 and 25 only.




== Remove support for apoc

No apoc functions or procedures are supported in Cypher Builder 3. The following are no longer available:

- `apoc.util.validate`
- `apoc.util.validatePredicate`
- `apoc.date.convertFormat`
- `apoc.cypher.runFirstColumnMany`
- `apoc.cypher.runFirstColumnSingle`

To use apoc methods, create a xref:how-to/customize-cypher.adoc#_custom_functions_and_procedures[custom function or procedure]. For example:

[source, Javascript]
----
function validate(
    predicate: Predicate,
    message: string,
    params: List | Literal | Map
): Cypher.VoidCypherProcedure {
    return new Cypher.VoidCypherProcedure(
        "apoc.util.validate", 
        [predicate,  new Literal(message), params]
    );
}
----

[source, Javascript]
----
function validatePredicate(predicate: Predicate, message: string): CypherFunction {
    return new CypherFunction("
        apoc.util.validatePredicate", 
        [predicate, new Literal(message), new Literal([0])]
    );
}
----

== Cypher 4 only features

The following features have been either removed or deprecated in Cypher 5, and are no longer available in Cypher Builder 3


=== Remove functions deprecated in Cypher 5

- `distance` in favor of `point.distance`
- `id` in favor of `elementId`

=== Remove support for patterns in size

_No longer supported_

[source, javascript]
----
Cypher.size(new Cypher.Pattern(node));
----

[source, Cypher]
----
size((this0));
----

Instead, use `new Cypher.Count`:

[source, javascript]
----
new Cypher.Count(new Cypher.Pattern(node));
----

[source, Cypher]
----
COUNT {
    (this0)
}
----


=== Remove `labelOperator`

Removed option `labelOperator`. All labels now use operator `&`


_No longer supported_

[source, javascript]
----
const { cypher, params } = matchQuery.build({
    labelOperator: "&",
});
----


_Before_

[source, Cypher]
----
MATCH (this1:Movie:Film)
----

_After_

[source, Cypher]
----
MATCH (this1:Movie&Film)
----


=== Remove `.importWith` from `Call`

Remove `.importWith` from `Call` clauses in favor of constructor options

_No longer supported_

[source, Javascript]
----
const clause = new Cypher.Call(nestedClause).importWith(movieNode, actorNode);
----

[source, Cypher]
----
CALL {
    WITH var0, var1
    // Nested clause
}
----

_After_

[source, Javascript]
----
const clause = new Cypher.Call(nestedClause, [movieNode, actorNode]);
----

[source, Cypher]
----
CALL (var0, var1){
    // Nested clause
}
----


== ListComprehension

The methods for `ListComprehension` have been changed to improve consistency with other elements of Cypher Builder.


=== Remove second parameter of constructor
Remove second parameter of `ListComprehension` constructor in favor of `.in`

Before:
[source, javascript]
----
new Cypher.ListComprehension(variable, new Cypher.Literal([1, 2]));
----

After:
[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1, 2]));
----

In both cases, the same comprehension will be generated:

```cypher
[var0 IN [1, 2]]
```

=== ListComprehension `.in` method no longer throws if called twice.

ListComprehension `.in` method no longer throws if called twice. It will instead override the expression

Before, it will throw:
[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1, 2])).in(new Cypher.Literal([1]))
----

After, this is valid:
[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1, 2])).in(new Cypher.Literal([1]))
----

Will generate the following Cypher:

[source, cypher]
----
[var0 IN [1]]
----

Note that the same Cypher is generated if we omit the first `.in`:

After, this is valid:
[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1]))
----


== Foreach

The methods for `Foreach` have been changed to improve consistency with other elements of Cypher Builder.

=== Remove extra parameters in `Cypher.Foreach` constructor
Remove extra parameters in `Cypher.Foreach` constructor in favor of methods `in` and `do`.

For example, to create the following Cypher:

[source, Cypher]
----
FOREACH (var0 IN [1, 2, 3] |
        CREATE (this1:Movie)
        SET
            this1.id = var0
    )
----

_before_

[source, javascript]
----
const list = new Cypher.Literal([1, 2, 3]);
const variable = new Cypher.Variable();

const movieNode = new Cypher.Node();
const createMovie = new Cypher.Create(new Cypher.Pattern(movieNode, { labels: ["Movie"] })).set([
    movieNode.property("id"),
    variable,
]);

const foreachClause = new Cypher.Foreach(variable, list, createMovie);
----

_after_

[source, javascript]
----
const list = new Cypher.Literal([1, 2, 3]);
const variable = new Cypher.Variable();

const movieNode = new Cypher.Node();
const createMovie = new Cypher.Create(new Cypher.Pattern(movieNode, { labels: ["Movie"] })).set([
    movieNode.property("id"),
    variable,
]);

const foreachClause = new Cypher.Foreach(variable).in(list).do(createMovie);
----

== Other breaking changes

=== Remove method `.children` from concat clauses

[source, Javascript]
----
const query = Cypher.utils.concat(clause1, clause2);
query.children; // No longer supported
----

=== Remove type `Cypher.Operation`
Remove type `Cypher.Operation` in favor of `Cypher.Expr`

The type `Cypher.Operation` is no longer availabe, use `Cypher.Expr` instead:

Before:
[source, javascript]
----
const myOperation: Cypher.Operation = Cypher.and()
----

After:
[source, javascript]
----
const myOperation: Cypher.Expr = Cypher.and()
----

