[[migration]]
:description: This page describes how to migrate to version 3.x from version 2
= Migration to Cypher Builder 3

This guide details all the changes needed to migrate from Cypher Builder version 2 to version 3.

[NOTE]
====
If you need to support Neo4j 4, stay with Cypher Builder 2.x, otherwise, migrate to version 3.
====

== Compatibility changes

=== Minimum node engine changed to 20.0.0

Node.js 16 is no longer supported. Update Node.js to version 20.0.0 or above.

=== Cypher 4 no longer supported

Cypher 4, and Neo4j 4 databases are no longer supported. Cypher Builder 3 targets Cypher 5 and 25.

The following features are Cypher 4 only, and have been removed from Cypher Builder.

==== Removed functions deprecated in Cypher 5

- `distance` in favor of `point.distance`
- `id` in favor of `elementId`

==== Removed support for patterns in size

_No longer supported_
[source, javascript]
----
Cypher.size(new Cypher.Pattern(node));
----

[source, Cypher]
----
size((this0));
----

Instead, use `new Cypher.Count`:

[source, javascript]
----
new Cypher.Count(new Cypher.Pattern(node));
----

[source, Cypher]
----
COUNT {
    (this0)
}
----

==== Removed `labelOperator`

Removed option `labelOperator`. Now, the operator `&` is used by default when using multiple labels:  


_No longer supported_
[source, javascript]
----
const { cypher, params } = matchQuery.build({
    labelOperator: "&",
});
----


_Before_
[source, Cypher]
----
MATCH (this1:Movie:Film)
----

_After_
[source, Cypher]
----
MATCH (this1:Movie&Film)
----


==== Removed `.importWith` from `Call`

Remove `.importWith` from `Call` clauses in favor of constructor options

_No longer supported_

[source, Javascript]
----
const clause = new Cypher.Call(nestedClause).importWith(movieNode, actorNode);
----

[source, Cypher]
----
CALL {
    WITH var0, var1
    // Nested clause
}
----

_After_

[source, Javascript]
----
const clause = new Cypher.Call(nestedClause, [movieNode, actorNode]);
----

[source, Cypher]
----
CALL (var0, var1){
    // Nested clause
}
----

== Removed support for apoc

No apoc functions or procedures are supported in Cypher Builder 3. The following are no longer available:

- `apoc.util.validate`
- `apoc.util.validatePredicate`
- `apoc.date.convertFormat`
- `apoc.cypher.runFirstColumnMany`
- `apoc.cypher.runFirstColumnSingle`

To use apoc methods, create a xref:how-to/customize-cypher.adoc#_custom_functions_and_procedures[custom function or procedure]. For example:

[source, Javascript]
----
function validate(
    predicate: Predicate,
    message: string,
    params: List | Literal | Map
): Cypher.VoidCypherProcedure {
    return new Cypher.VoidCypherProcedure(
        "apoc.util.validate", 
        [predicate,  new Literal(message), params]
    );
}
----

[source, Javascript]
----
function validatePredicate(predicate: Predicate, message: string): CypherFunction {
    return new CypherFunction("
        apoc.util.validatePredicate", 
        [predicate, new Literal(message), new Literal([0])]
    );
}
----

== API changes
The following are changes to the API, made to improve consistency across the Cypher Builder API.

=== ListComprehension

==== Remove second parameter of constructor
Remove second parameter of `ListComprehension` constructor in favor of `.in`

Before:
[source, javascript]
----
new Cypher.ListComprehension(variable, new Cypher.Literal([1, 2]));
----

After:
[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1, 2]));
----

In both cases, the same comprehension will be generated:

```cypher
[var0 IN [1, 2]]
```

==== ListComprehension `.in` method no longer throws if called twice.

ListComprehension `.in` method no longer throws if called twice. It will instead override the expression

Before, it will throw:
[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1, 2])).in(new Cypher.Literal([1]))
----

After, this is valid:
[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1, 2])).in(new Cypher.Literal([1]))
----

Will generate the following Cypher:

[source, cypher]
----
[var0 IN [1]]
----

Note that the same Cypher is generated if we omit the first `.in`:

[source, javascript]
----
new Cypher.ListComprehension(variable).in(new Cypher.Literal([1]))
----


=== Foreach

==== Remove extra parameters in `Cypher.Foreach` constructor
Remove extra parameters in `Cypher.Foreach` constructor in favor of methods `in` and `do`.

For example, to create the following Cypher:

[source, Cypher]
----
FOREACH (var0 IN [1, 2, 3] |
        CREATE (this1:Movie)
        SET
            this1.id = var0
    )
----

_Before_

[source, javascript]
----
const list = new Cypher.Literal([1, 2, 3]);
const variable = new Cypher.Variable();

const movieNode = new Cypher.Node();
const createMovie = new Cypher.Create(new Cypher.Pattern(movieNode, { labels: ["Movie"] })).set([
    movieNode.property("id"),
    variable,
]);

const foreachClause = new Cypher.Foreach(variable, list, createMovie);
----

_After_

[source, javascript]
----
const list = new Cypher.Literal([1, 2, 3]);
const variable = new Cypher.Variable();

const movieNode = new Cypher.Node();
const createMovie = new Cypher.Create(new Cypher.Pattern(movieNode, { labels: ["Movie"] })).set([
    movieNode.property("id"),
    variable,
]);

const foreachClause = new Cypher.Foreach(variable).in(list).do(createMovie);
----

== Other breaking changes

=== Remove method `.children` from concat clauses

[source, Javascript]
----
const query = Cypher.utils.concat(clause1, clause2);
query.children; // No longer supported
----

=== Remove type `Operation`

The type `Cypher.Operation` is no longer availabe, use `Cypher.Expr` instead:

_Before_
[source, javascript]
----
const myOperation: Cypher.Operation = Cypher.and()
----

_After_
[source, javascript]
----
const myOperation: Cypher.Expr = Cypher.and()
----

== Other changes

=== Change Cypher formatting

The generated Cypher now follow the best practices recommended by the link:https://neo4j.com/docs/cypher-manual/current/styleguide/[Cypher Styleguide].

For example:

_Before_
[source, Cypher]
----
CALL {
    CREATE (this0:Movie)
    SET
        this0.id = "The Matrix"
    RETURN this0
}
RETURN this0
----

_After_
[source, Cypher]
----
CALL {
  CREATE (this0:Movie)
    SET this0.id = 'The Matrix'
  RETURN this0
}
RETURN this0
----

This doesn't have any impact on the behaviour itself, and should not cause any breaking changes on normal usage, but may affect projects
that modify or test the Cypher generated with Cypher Builder.
